{"version":3,"sources":["AlgoVisualizer/Node/Node.jsx","algorithms/aStar.js","algorithms/dijkstra.js","mazeAlgorithms/recursiveBacktracker.js","mazeAlgorithms/recursiveBacktrackerNarrow.js","algorithms/breadthFirstSearch.js","algorithms/depthFirstSearch.js","AlgoVisualizer/components/MazeGenerator.js","AlgoVisualizer/components/AlgoSelection.js","mazeAlgorithms/initializeBorders.js","AlgoVisualizer/AlgoVisualizer.jsx","AlgoVisualizer/utilityFunctions.js","App.js","serviceWorker.js","index.js"],"names":["Node","this","props","col","isFinish","isStart","isWall","onMouseDown","onMouseEnter","onMouseUp","row","extraClassName","id","className","Component","astar","grid","startNode","finishNode","visitedNodesInOrder","gcost","hcost","fcost","unvisitedNodes","nodes","node","push","getAllNodes","length","sortNodesByFCost","closestNode","shift","Infinity","isVisited","updateUnvisitedNeighbors","sort","nodeA","nodeB","handleSort","unvisitedNeighbors","neighbors","filter","neighbor","getUnvisitedNeighbors","Math","sqrt","pow","previousNode","dijkstra","distance","sortNodesByDistance","initBorders","borderedGrid","slice","isBorder","newNode","depthFirstSearch","currentNode","visitedNodes","openingNodes","nodesStack","nextNode","checkUnvisitedNeighbors","declareOpenings","pop","generateMazeOpenings","top","right","bottom","left","includes","selectRandomNeighbor","floor","random","randomizedMazeGrid","getNextNode","selectNeighbor","MazeGenerator","onClick","handleGenerateMaze","handleGenerateMazeNarrow","handleClearMaze","handleContinue","AlgoSelection","handleVisualize","initializeBorders","AlgoVisualizer","state","mouseIsPressed","phase","getInitialGrid","setState","newPhase","recursiveBacktracker","recursiveBacktrackerNarrow","window","location","reload","newGrid","getNewGridWithWallToggled","nodesInShortestPathOrder","i","setTimeout","animateShortestPath","document","getElementById","algo","nodesQueue","breadthFirstSearch","unshift","getNodesInShortestPathOrder","animateAlgo","phaseView","bind","visualizeAlgo","handleReset","map","rowIdx","key","nodeIdx","handleMouseDown","handleMouseEnter","handleMouseUp","currentRow","createNode","App","Boolean","hostname","match","ReactDOM","render","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.090ab47f.chunk.js","sourcesContent":["import React, { Component } from \"react\";\n\nimport \"./Node.css\";\n\nexport default class Node extends Component {\n  render() {\n    const {\n      col,\n      isFinish,\n      isStart,\n      isWall,\n      onMouseDown,\n      onMouseEnter,\n      onMouseUp,\n      row\n    } = this.props;\n    const extraClassName = isFinish\n      ? \"node-finish\"\n      : isStart\n      ? \"node-start\"\n      : isWall\n      ? \"node-wall\"\n      : \"\";\n\n    return (\n      <div\n        id={`node-${row}-${col}`}\n        className={`node ${extraClassName}`}\n        onMouseDown={() => onMouseDown(row, col)}\n        onMouseEnter={() => onMouseEnter(row, col)}\n        onMouseUp={() => onMouseUp()}\n      ></div>\n    );\n  }\n}\n","export function astar(grid, startNode, finishNode) {\n  const visitedNodesInOrder = [];\n  startNode.gcost = 0;\n  startNode.hcost = 0;\n  startNode.fcost = 0;\n\n  const unvisitedNodes = getAllNodes(grid);\n  while (!!unvisitedNodes.length) {\n    sortNodesByFCost(unvisitedNodes);\n    const closestNode = unvisitedNodes.shift();\n    if (closestNode.isWall) continue;\n    if (closestNode.fcost === Infinity) return visitedNodesInOrder;\n    closestNode.isVisited = true;\n    visitedNodesInOrder.push(closestNode);\n    if (closestNode === finishNode) return visitedNodesInOrder;\n    updateUnvisitedNeighbors(closestNode, grid, finishNode);\n  }\n}\n\nfunction sortNodesByFCost(unvisitedNodes) {\n  unvisitedNodes.sort((nodeA, nodeB) => handleSort(nodeA, nodeB));\n}\n\nfunction handleSort(nodeA, nodeB) {\n  if (nodeA.fcost === nodeB.fcost) return nodeA.hcost - nodeB.hcost;\n  else return nodeA.fcost - nodeB.fcost;\n}\n\nfunction updateUnvisitedNeighbors(node, grid, finishNode) {\n  const unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\n  for (const neighbor of unvisitedNeighbors) {\n    neighbor.gcost = node.gcost + 1;\n    neighbor.hcost =\n      node.hcost +\n      Math.sqrt(\n        Math.pow(finishNode.col - node.col, 2) +\n          Math.pow(node.row - finishNode.row, 2)\n      );\n    neighbor.fcost = neighbor.gcost + neighbor.hcost;\n    neighbor.previousNode = node;\n  }\n}\n\nfunction getUnvisitedNeighbors(node, grid) {\n  const neighbors = [];\n  const { col, row } = node;\n  if (row > 0) neighbors.push(grid[row - 1][col]);\n  if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\n  if (col > 0) neighbors.push(grid[row][col - 1]);\n  if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\n  return neighbors.filter((neighbor) => !neighbor.isVisited);\n}\n\nfunction getAllNodes(grid) {\n  const nodes = [];\n  for (const row of grid) {\n    for (const node of row) {\n      nodes.push(node);\n    }\n  }\n  return nodes;\n}\n","export function dijkstra(grid, startNode, finishNode) {\n  const visitedNodesInOrder = [];\n  startNode.distance = 0;\n  const unvisitedNodes = getAllNodes(grid);\n  while (!!unvisitedNodes.length) {\n    sortNodesByDistance(unvisitedNodes);\n    const closestNode = unvisitedNodes.shift();\n    if (closestNode.isWall) continue;\n    if (closestNode.distance === Infinity) return visitedNodesInOrder;\n    closestNode.isVisited = true;\n    visitedNodesInOrder.push(closestNode);\n    if (closestNode === finishNode) return visitedNodesInOrder;\n    updateUnvisitedNeighbors(closestNode, grid);\n  }\n}\n\nfunction sortNodesByDistance(unvisitedNodes) {\n  unvisitedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\n}\n\nfunction updateUnvisitedNeighbors(node, grid) {\n  const unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\n  for (const neighbor of unvisitedNeighbors) {\n    neighbor.distance = node.distance + 1;\n    neighbor.previousNode = node;\n  }\n}\n\nfunction getUnvisitedNeighbors(node, grid) {\n  const neighbors = [];\n  const { col, row } = node;\n  if (row > 0) neighbors.push(grid[row - 1][col]);\n  if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\n  if (col > 0) neighbors.push(grid[row][col - 1]);\n  if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\n  return neighbors.filter((neighbor) => !neighbor.isVisited);\n}\n\nfunction getAllNodes(grid) {\n  const nodes = [];\n  for (const row of grid) {\n    for (const node of row) {\n      nodes.push(node);\n    }\n  }\n  return nodes;\n}\n","export const recursiveBacktracker = (grid) => {\n  const borderedGrid = initBorders(grid);\n  const randomizedMazeGrid = depthFirstSearch(borderedGrid);\n  return randomizedMazeGrid;\n};\n\nconst initBorders = (grid) => {\n  const borderedGrid = grid.slice();\n  for (let row = 0; row < 21; row++) {\n    for (let col = 0; col < 49; col++) {\n      const node = borderedGrid[row][col];\n      if (isBorder(row, col)) {\n        const newNode = {\n          ...node,\n          isWall: !node.isWall,\n        };\n        borderedGrid[row][col] = newNode;\n      }\n    }\n  }\n\n  return borderedGrid;\n};\n\nconst isBorder = (row, col) => {\n  return row % 4 === 0 || col % 4 === 0;\n};\n\nconst depthFirstSearch = (borderedGrid) => {\n  var currentNode = borderedGrid[2][2];\n  var visitedNodes = [];\n  var openingNodes = [];\n  var nodesStack = [];\n  visitedNodes.push(currentNode);\n  while (!!currentNode) {\n    // Choose randomly one of the unvisited neighbours\n    var nextNode = checkUnvisitedNeighbors(\n      currentNode,\n      borderedGrid,\n      visitedNodes\n    );\n    if (nextNode) {\n      visitedNodes.push(nextNode);\n      // Make the chosen cell the current cell and mark it as visited\n      declareOpenings(borderedGrid, currentNode, nextNode, openingNodes); // Add \"openings\" to openingNodes\n      nodesStack.push(currentNode);\n      currentNode = nextNode;\n    } else {\n      currentNode = nodesStack.pop();\n    }\n  }\n\n  // After everything is done, iterate through the entire grid\n  // and toggle all instances of nodes that are opening nodes\n\n  // Return grid with openings\n  return generateMazeOpenings(borderedGrid, openingNodes);\n};\n\nconst checkUnvisitedNeighbors = (currentNode, borderedGrid, visitedNodes) => {\n  var unvisitedNeighbors = [];\n  if (currentNode.row >= 6) {\n    var top = borderedGrid[currentNode.row - 4][currentNode.col];\n  }\n  if (currentNode.col <= 42) {\n    var right = borderedGrid[currentNode.row][currentNode.col + 4];\n  }\n  if (currentNode.row <= 14) {\n    var bottom = borderedGrid[currentNode.row + 4][currentNode.col];\n  }\n  if (currentNode.col >= 6) {\n    var left = borderedGrid[currentNode.row][currentNode.col - 4];\n  }\n  if (top && !visitedNodes.includes(top)) {\n    unvisitedNeighbors.push(top);\n  }\n  if (right && !visitedNodes.includes(right)) {\n    unvisitedNeighbors.push(right);\n  }\n  if (bottom && !visitedNodes.includes(bottom)) {\n    unvisitedNeighbors.push(bottom);\n  }\n  if (left && !visitedNodes.includes(left)) {\n    unvisitedNeighbors.push(left);\n  }\n\n  // returns undefined if there are no unvisited neighbors\n  var randomNeighbor = selectRandomNeighbor(unvisitedNeighbors);\n  return randomNeighbor;\n};\n\nconst selectRandomNeighbor = (unvisitedNeighbors) => {\n  if (unvisitedNeighbors.length > 0) {\n    var i = Math.floor(Math.random() * Math.floor(unvisitedNeighbors.length));\n    return unvisitedNeighbors[i];\n  } else {\n    return undefined;\n  }\n};\n\nconst declareOpenings = (borderedGrid, currentNode, nextNode, openingNodes) => {\n  var classifyNeighbor;\n  if (nextNode.row - currentNode.row === -4) {\n    classifyNeighbor = \"top\";\n  } else if (nextNode.col - currentNode.col === 4) {\n    classifyNeighbor = \"right\";\n  } else if (nextNode.row - currentNode.row === 4) {\n    classifyNeighbor = \"bottom\";\n  } else {\n    classifyNeighbor = \"left\";\n  }\n  switch (classifyNeighbor) {\n    case \"top\":\n      openingNodes.push(borderedGrid[currentNode.row - 2][currentNode.col - 1]);\n      openingNodes.push(borderedGrid[currentNode.row - 2][currentNode.col]);\n      openingNodes.push(borderedGrid[currentNode.row - 2][currentNode.col + 1]);\n      break;\n    case \"right\":\n      openingNodes.push(borderedGrid[currentNode.row - 1][currentNode.col + 2]);\n      openingNodes.push(borderedGrid[currentNode.row][currentNode.col + 2]);\n      openingNodes.push(borderedGrid[currentNode.row + 1][currentNode.col + 2]);\n      break;\n    case \"bottom\":\n      openingNodes.push(borderedGrid[currentNode.row + 2][currentNode.col - 1]);\n      openingNodes.push(borderedGrid[currentNode.row + 2][currentNode.col]);\n      openingNodes.push(borderedGrid[currentNode.row + 2][currentNode.col + 1]);\n      break;\n    case \"left\":\n      openingNodes.push(borderedGrid[currentNode.row - 1][currentNode.col - 2]);\n      openingNodes.push(borderedGrid[currentNode.row][currentNode.col - 2]);\n      openingNodes.push(borderedGrid[currentNode.row + 1][currentNode.col - 2]);\n      break;\n    default:\n      break;\n  }\n};\n\nconst generateMazeOpenings = (borderedGrid, openingNodes) => {\n  const randomizedMazeGrid = borderedGrid.slice();\n  for (let row = 0; row < 21; row++) {\n    for (let col = 0; col < 49; col++) {\n      const node = borderedGrid[row][col];\n      if (openingNodes.includes(node)) {\n        const newNode = {\n          ...node,\n          isWall: !node.isWall,\n        };\n        borderedGrid[row][col] = newNode;\n      }\n    }\n  }\n\n  return randomizedMazeGrid;\n};\n","export const recursiveBacktrackerNarrow = grid => {\n  const borderedGrid = initBorders(grid);\n  const randomizedMazeGrid = depthFirstSearch(borderedGrid);\n  return randomizedMazeGrid;\n};\n\nconst initBorders = grid => {\n  const borderedGrid = grid.slice();\n  for (let row = 0; row < 21; row++) {\n    for (let col = 0; col < 49; col++) {\n      const node = borderedGrid[row][col];\n      if (isBorder(row, col)) {\n        const newNode = {\n          ...node,\n          isWall: !node.isWall\n        };\n        borderedGrid[row][col] = newNode;\n      }\n    }\n  }\n\n  return borderedGrid;\n};\n\nconst isBorder = (row, col) => {\n  return (\n    row !== 0 &&\n    col !== 0 &&\n    row !== 20 &&\n    col !== 48 &&\n    (row % 2 !== 0 || col % 2 !== 0)\n  );\n};\n\nconst depthFirstSearch = borderedGrid => {\n  var currentNode = borderedGrid[2][2];\n  var visitedNodes = [];\n  var openingNodes = [];\n  var nodesStack = [];\n  visitedNodes.push(currentNode);\n  while (!!currentNode) {\n    var nextNode = checkUnvisitedNeighbors(\n      currentNode,\n      borderedGrid,\n      visitedNodes\n    );\n    if (nextNode) {\n      visitedNodes.push(nextNode);\n      declareOpenings(borderedGrid, currentNode, nextNode, openingNodes);\n      nodesStack.push(currentNode);\n      currentNode = nextNode;\n    } else {\n      currentNode = nodesStack.pop();\n    }\n  }\n  return generateMazeOpenings(borderedGrid, openingNodes);\n};\n\nconst checkUnvisitedNeighbors = (currentNode, borderedGrid, visitedNodes) => {\n  var unvisitedNeighbors = [];\n  if (currentNode.row >= 4) {\n    var top = borderedGrid[currentNode.row - 2][currentNode.col];\n  }\n  if (currentNode.col <= 45) {\n    var right = borderedGrid[currentNode.row][currentNode.col + 2];\n  }\n  if (currentNode.row <= 17) {\n    var bottom = borderedGrid[currentNode.row + 2][currentNode.col];\n  }\n  if (currentNode.col >= 4) {\n    var left = borderedGrid[currentNode.row][currentNode.col - 2];\n  }\n  if (top && !visitedNodes.includes(top)) {\n    unvisitedNeighbors.push(top);\n  }\n  if (right && !visitedNodes.includes(right)) {\n    unvisitedNeighbors.push(right);\n  }\n  if (bottom && !visitedNodes.includes(bottom)) {\n    unvisitedNeighbors.push(bottom);\n  }\n  if (left && !visitedNodes.includes(left)) {\n    unvisitedNeighbors.push(left);\n  }\n\n  // returns undefined if there are no unvisited neighbors\n  var randomNeighbor = selectRandomNeighbor(unvisitedNeighbors);\n  return randomNeighbor;\n};\n\nconst selectRandomNeighbor = unvisitedNeighbors => {\n  if (unvisitedNeighbors.length > 0) {\n    var i = Math.floor(Math.random() * Math.floor(unvisitedNeighbors.length));\n    return unvisitedNeighbors[i];\n  } else {\n    return undefined;\n  }\n};\n\nconst declareOpenings = (borderedGrid, currentNode, nextNode, openingNodes) => {\n  var classifyNeighbor;\n  if (nextNode.row - currentNode.row === -2) {\n    classifyNeighbor = \"top\";\n  } else if (nextNode.col - currentNode.col === 2) {\n    classifyNeighbor = \"right\";\n  } else if (nextNode.row - currentNode.row === 2) {\n    classifyNeighbor = \"bottom\";\n  } else {\n    classifyNeighbor = \"left\";\n  }\n  switch (classifyNeighbor) {\n    case \"top\":\n      openingNodes.push(borderedGrid[currentNode.row - 1][currentNode.col]);\n      break;\n    case \"right\":\n      openingNodes.push(borderedGrid[currentNode.row][currentNode.col + 1]);\n      break;\n    case \"bottom\":\n      openingNodes.push(borderedGrid[currentNode.row + 1][currentNode.col]);\n      break;\n    case \"left\":\n      openingNodes.push(borderedGrid[currentNode.row][currentNode.col - 1]);\n      break;\n    default:\n      break;\n  }\n};\n\nconst generateMazeOpenings = (borderedGrid, openingNodes) => {\n  const randomizedMazeGrid = borderedGrid.slice();\n  for (let row = 0; row < 21; row++) {\n    for (let col = 0; col < 49; col++) {\n      const node = borderedGrid[row][col];\n      if (openingNodes.includes(node)) {\n        const newNode = {\n          ...node,\n          isWall: !node.isWall\n        };\n        borderedGrid[row][col] = newNode;\n      }\n    }\n  }\n\n  return randomizedMazeGrid;\n};\n","export function breadthFirstSearch(grid, startNode, finishNode) {\n  var nodesQueue = [];\n  var visitedNodesInOrder = [];\n  var currentNode = startNode;\n  nodesQueue.push(currentNode);\n  visitedNodesInOrder.push(currentNode);\n  currentNode.isVisited = true;\n  while (!!currentNode) {\n    if (currentNode === finishNode) return visitedNodesInOrder;\n    var unvisitedNeighbors = getUnvisitedNeighbors(currentNode, grid);\n    while (unvisitedNeighbors.length > 0) {\n      var nextNode = unvisitedNeighbors.shift();\n      nextNode.previousNode = currentNode;\n      currentNode = nextNode;\n      nodesQueue.push(currentNode);\n      visitedNodesInOrder.push(currentNode);\n      currentNode.isVisited = true;\n    }\n    currentNode = nodesQueue.shift();\n  }\n  return visitedNodesInOrder;\n}\n\nconst getUnvisitedNeighbors = (node, grid) => {\n  var neighbors = [];\n  const { col, row } = node;\n  if (row > 0) neighbors.push(grid[row - 1][col]);\n  if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\n  if (col > 0) neighbors.push(grid[row][col - 1]);\n  if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\n  return neighbors.filter(\n    (neighbor) => !neighbor.isVisited && !neighbor.isWall\n  );\n};\n","export function depthFirstSearch(grid, startNode, finishNode) {\n  var nodesStack = [];\n  var visitedNodesInOrder = [];\n  var currentNode = startNode;\n  nodesStack.push(currentNode);\n  visitedNodesInOrder.push(currentNode);\n  currentNode.isVisited = true;\n  while (!!currentNode) {\n    if (currentNode === finishNode) return visitedNodesInOrder;\n    var nextNode = getNextNode(currentNode, grid);\n    if (!!nextNode) {\n      nextNode.previousNode = currentNode;\n      currentNode = nextNode;\n      nodesStack.push(currentNode);\n      visitedNodesInOrder.push(currentNode);\n      currentNode.isVisited = true;\n    } else {\n      currentNode = nodesStack.pop();\n    }\n  }\n  return visitedNodesInOrder;\n}\n\nconst getNextNode = (node, grid) => {\n  var neighbors = [];\n  const { col, row } = node;\n  if (row > 0) neighbors.push(grid[row - 1][col]);\n  if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\n  if (col > 0) neighbors.push(grid[row][col - 1]);\n  if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\n  const unvisitedNeighbors = neighbors.filter(\n    (neighbor) => !neighbor.isVisited && !neighbor.isWall\n  );\n\n  var nextNode = selectNeighbor(unvisitedNeighbors);\n  return nextNode;\n};\n\nconst selectNeighbor = (unvisitedNeighbors) => {\n  if (unvisitedNeighbors.length > 0) {\n    return unvisitedNeighbors.pop();\n  } else {\n    return undefined;\n  }\n};\n","import React, { Component } from \"react\";\n\nexport default class MazeGenerator extends Component {\n  render() {\n    return (\n      <>\n        <button\n          className=\"action-button\"\n          onClick={() => this.props.handleGenerateMaze()}\n        >\n          <text className=\"button-text\">Generate Wide Maze</text>\n        </button>\n        <button\n          className=\"action-button\"\n          onClick={() => this.props.handleGenerateMazeNarrow()}\n        >\n          <text className=\"button-text\">Generate Narrow Maze</text>\n        </button>\n        <button\n          className=\"action-button\"\n          onClick={() => this.props.handleClearMaze()}\n        >\n          <text className=\"reset-text\">Clear</text>\n        </button>\n        <button\n          className=\"action-button\"\n          onClick={() => this.props.handleContinue()}\n        >\n          <text className=\"continue-text\">Continue</text>\n        </button>\n      </>\n    );\n  }\n}\n","import React, { Component } from \"react\";\n\nexport default class AlgoSelection extends Component {\n  render() {\n    return (\n      <>\n        <button\n          className=\"action-button\"\n          onClick={() => this.props.handleVisualize(\"dijkstra\")}\n        >\n          <text className=\"button-text\">Dijkstra's</text>\n        </button>\n        <button\n          className=\"action-button\"\n          onClick={() => this.props.handleVisualize(\"astar\")}\n        >\n          <text className=\"button-text\">A* Search</text>\n        </button>\n        <button\n          className=\"action-button\"\n          onClick={() => this.props.handleVisualize(\"dfs\")}\n        >\n          <text className=\"button-text\">DFS</text>\n        </button>\n        <button\n          className=\"action-button\"\n          onClick={() => this.props.handleVisualize(\"bfs\")}\n        >\n          <text className=\"button-text\">BFS</text>\n        </button>\n      </>\n    );\n  }\n}\n","export const initializeBorders = (grid) => {\n  return initBorders(grid);\n};\n\nconst initBorders = (grid) => {\n  const borderedGrid = grid.slice();\n  for (let row = 0; row < 21; row++) {\n    for (let col = 0; col < 49; col++) {\n      const node = borderedGrid[row][col];\n      if (isBorder(row, col)) {\n        const newNode = {\n          ...node,\n          isWall: !node.isWall,\n        };\n        borderedGrid[row][col] = newNode;\n      }\n    }\n  }\n\n  return borderedGrid;\n};\n\nconst isBorder = (row, col) => {\n  return row === 0 || row === 20 || col === 0 || col === 48;\n};\n","import React, { Component } from \"react\";\nimport Node from \"./Node/Node\";\nimport { astar } from \"../algorithms/aStar\";\nimport { dijkstra } from \"../algorithms/dijkstra\";\nimport { recursiveBacktracker } from \"../mazeAlgorithms/recursiveBacktracker\";\nimport { recursiveBacktrackerNarrow } from \"../mazeAlgorithms/recursiveBacktrackerNarrow\";\nimport { breadthFirstSearch } from \"../algorithms/breadthFirstSearch\";\nimport { depthFirstSearch } from \"../algorithms/depthFirstSearch\";\nimport { getNodesInShortestPathOrder } from \"./utilityFunctions\";\nimport \"./AlgoVisualizer.css\";\nimport MazeGenerator from \"./components/MazeGenerator\";\nimport AlgoSelection from \"./components/AlgoSelection\";\nimport { initializeBorders } from \"../mazeAlgorithms/initializeBorders\";\n\nconst START_NODE_ROW = 2;\nconst START_NODE_COL = 2;\nconst FINISH_NODE_ROW = 18;\nconst FINISH_NODE_COL = 46;\n\nexport default class AlgoVisualizer extends Component {\n  constructor() {\n    super();\n    this.state = {\n      grid: [],\n      mouseIsPressed: false,\n      phase: 0,\n    };\n  }\n\n  componentDidMount() {\n    const grid = getInitialGrid();\n    const borderedGrid = initializeBorders(grid);\n    this.setState({ grid: borderedGrid });\n  }\n\n  handleClearMaze() {\n    const grid = getInitialGrid();\n    const borderedGrid = initializeBorders(grid);\n    this.setState({ grid: borderedGrid });\n  }\n\n  handleContinue() {\n    var newPhase = this.state.phase + 1;\n    this.setState({ phase: newPhase });\n  }\n\n  handleGenerateMaze() {\n    const resetGrid = getInitialGrid();\n    const borderedGrid = recursiveBacktracker(resetGrid);\n    this.setState({ grid: borderedGrid });\n  }\n\n  handleGenerateMazeNarrow() {\n    const resetGrid = getInitialGrid();\n    const borderedGrid = recursiveBacktrackerNarrow(resetGrid);\n    this.setState({ grid: borderedGrid });\n  }\n\n  handleReset() {\n    window.location.reload();\n  }\n\n  handleMouseDown(row, col) {\n    const newGrid = getNewGridWithWallToggled(this.state.grid, row, col);\n    this.setState({ grid: newGrid, mouseIsPressed: true });\n  }\n\n  handleMouseEnter(row, col) {\n    if (!this.state.mouseIsPressed) return;\n    const newGrid = getNewGridWithWallToggled(this.state.grid, row, col);\n    this.setState({ grid: newGrid });\n  }\n\n  handleMouseUp() {\n    this.setState({ mouseIsPressed: false });\n  }\n\n  animateAlgo(visitedNodesInOrder, nodesInShortestPathOrder) {\n    for (let i = 0; i <= visitedNodesInOrder.length; i++) {\n      if (i === visitedNodesInOrder.length) {\n        setTimeout(() => {\n          this.animateShortestPath(nodesInShortestPathOrder);\n        }, 10 * i);\n        return;\n      }\n      setTimeout(() => {\n        const node = visitedNodesInOrder[i];\n        document.getElementById(`node-${node.row}-${node.col}`).className =\n          \"node node-visited\";\n      }, 10 * i);\n    }\n  }\n\n  animateShortestPath(nodesInShortestPathOrder) {\n    for (let i = 0; i < nodesInShortestPathOrder.length; i++) {\n      setTimeout(() => {\n        const node = nodesInShortestPathOrder[i];\n        document.getElementById(`node-${node.row}-${node.col}`).className =\n          \"node node-shortest-path\";\n      }, 30 * i);\n    }\n  }\n\n  visualizeAlgo(algo) {\n    this.handleContinue();\n    const { grid } = this.state;\n    const startNode = grid[START_NODE_ROW][START_NODE_COL];\n    const finishNode = grid[FINISH_NODE_ROW][FINISH_NODE_COL];\n    var visitedNodesInOrder = [];\n    switch (algo) {\n      case \"dijkstra\":\n        visitedNodesInOrder = dijkstra(grid, startNode, finishNode);\n        break;\n      case \"astar\":\n        visitedNodesInOrder = astar(grid, startNode, finishNode);\n        break;\n      case \"bfs\":\n        visitedNodesInOrder = breadthFirstSearch(grid, startNode, finishNode);\n        break;\n      case \"dfs\":\n        visitedNodesInOrder = depthFirstSearch(grid, startNode, finishNode);\n        break;\n    }\n    const nodesInShortestPathOrder = getNodesInShortestPathOrder(finishNode);\n    this.animateAlgo(visitedNodesInOrder, nodesInShortestPathOrder);\n  }\n\n  render() {\n    const { grid, mouseIsPressed } = this.state;\n    var phaseView;\n    switch (this.state.phase) {\n      case 0:\n        phaseView = (\n          <MazeGenerator\n            handleGenerateMaze={this.handleGenerateMaze.bind(this)}\n            handleGenerateMazeNarrow={this.handleGenerateMazeNarrow.bind(this)}\n            handleClearMaze={this.handleClearMaze.bind(this)}\n            handleContinue={this.handleContinue.bind(this)}\n          />\n        );\n        break;\n      case 1:\n        phaseView = (\n          <AlgoSelection handleVisualize={(algo) => this.visualizeAlgo(algo)} />\n        );\n        break;\n      case 2:\n        phaseView = (\n          <>\n            <button\n              className=\"action-button\"\n              onClick={() => this.handleReset()}\n            >\n              <text className=\"continue-text\">Reset</text>\n            </button>\n          </>\n        );\n        break;\n    }\n\n    return (\n      <div className=\"main\">\n        <div className=\"header-div\">\n          <h1 className=\"header\">Maze Runner</h1>\n        </div>\n        <div className=\"content\">\n          <div className=\"button-container\">{phaseView}</div>\n          <div className=\"grid\">\n            {grid.map((row, rowIdx) => {\n              return (\n                <div key={rowIdx}>\n                  {row.map((node, nodeIdx) => {\n                    const { row, col, isFinish, isStart, isWall } = node;\n                    return (\n                      <Node\n                        key={nodeIdx}\n                        col={col}\n                        isFinish={isFinish}\n                        isStart={isStart}\n                        isWall={isWall}\n                        mouseIsPressed={mouseIsPressed}\n                        onMouseDown={(row, col) =>\n                          this.handleMouseDown(row, col)\n                        }\n                        onMouseEnter={(row, col) =>\n                          this.handleMouseEnter(row, col)\n                        }\n                        onMouseUp={() => this.handleMouseUp()}\n                        row={row}\n                      ></Node>\n                    );\n                  })}\n                </div>\n              );\n            })}\n          </div>\n        </div>\n      </div>\n    );\n  }\n}\n\nconst getInitialGrid = () => {\n  const grid = [];\n  for (let row = 0; row < 21; row++) {\n    const currentRow = [];\n    for (let col = 0; col < 49; col++) {\n      currentRow.push(createNode(col, row));\n    }\n    grid.push(currentRow);\n  }\n  return grid;\n};\n\nconst createNode = (col, row) => {\n  return {\n    col,\n    row,\n    isStart: row === START_NODE_ROW && col === START_NODE_COL,\n    isFinish: row === FINISH_NODE_ROW && col === FINISH_NODE_COL,\n    distance: Infinity,\n    gcost: Infinity,\n    hcost: Infinity,\n    fcost: Infinity,\n    isVisited: false,\n    isWall: false,\n    previousNode: null,\n  };\n};\n\nconst getNewGridWithWallToggled = (grid, row, col) => {\n  const newGrid = grid.slice();\n  const node = newGrid[row][col];\n  const newNode = {\n    ...node,\n    isWall: !node.isWall,\n  };\n  newGrid[row][col] = newNode;\n  return newGrid;\n};\n","export function getNodesInShortestPathOrder(finishNode) {\n  const nodesInShortestPathOrder = [];\n  let currentNode = finishNode;\n  while (currentNode !== null) {\n    nodesInShortestPathOrder.unshift(currentNode);\n    currentNode = currentNode.previousNode;\n  }\n  return nodesInShortestPathOrder;\n}\n","import React from \"react\";\nimport \"./App.css\";\n\n// Components\nimport AlgoVisualizer from \"./AlgoVisualizer/AlgoVisualizer\";\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <AlgoVisualizer></AlgoVisualizer>\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}